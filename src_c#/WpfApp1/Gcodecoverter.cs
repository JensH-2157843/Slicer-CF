using System.IO;
using System.Text;
using Clipper2Lib;

namespace WpfApp1;

public class Gcodecoverter
{
    // variable
    private readonly string _newline = "\n";
    private double _e = 0.0;
    private double _nozzleSize = 0.4;
    private double _layerHeight = 0.2;
    private double _filamentArea = 2.4052818754047; // pi * (filimant_radius)² = 1.75/2
    private double tolerance = 0.000001;
        

    public void Gcode(PathsD paths, string filename = "C://Users//jensh//Documents//GitHub//CompFab-Slicer//test.gcode"){
        using FileStream fs = File.Create(filename);
        writeCommonInfo(fs);
        writeCustomGcode(fs, paths);
        writeEndLines(fs);
    }

    private void writeCommonInfo(FileStream fs)
    {
        string header = "(This is a G-code file generated by GcodeConverter)" + _newline +
                        "(Generated on: " + DateTime.Now + ")" + _newline +
                        "M140 S50" + _newline +
                        "M105" + _newline +
                        "M190 S50" + _newline +
                        "M104 S120" + _newline +
                        "M105" + _newline +
                        "M109 S120" + _newline +
                        "M82 ;absolute extrusion mode" + _newline +
                        "G92 E0 ; Reset Extruder" + _newline +
                        "G28 ; Home all axes" + _newline +
                        "G1 Z2.0 F3000 ; Move Z Axis up little to prevent scratching of Heat Bed" + _newline +
                        "G1 X0.1 Y20 Z0.3 F5000.0 ; Move to start position" + _newline +
                        "G1 X0.1 Y200.0 Z0.3 F1500.0 E15 ; Draw the first line" + _newline +
                        "G1 X0.4 Y200.0 Z0.3 F5000.0 ; Move to side a little" + _newline +
                        "G1 X0.4 Y20 Z0.3 F1500.0 E30 ; Draw the second line" + _newline +
                        "G92 E0 ; Reset Extruder" + _newline +
                        "G1 Z2.0 F3000 ; Move Z Axis up little to prevent scratching of Heat Bed" + _newline +
                        "G1 X5 Y20 Z0.3 F5000.0 ; Move over to prevent blob squish" + _newline +
                        "G92 E0" + _newline +
                        "G92 E0" + _newline;

        // Convert string to bytes and write to the file
        byte[] headerBytes = Encoding.UTF8.GetBytes(header);
        fs.Write(headerBytes, 0, headerBytes.Length);
    }

    private double callculate_E(PointD p1, PointD p2)
    {
        double deltaX = p2.x - p1.x;
        double deltaY = p2.y - p1.y;
        
        double length = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        
        _e +=  (length * _nozzleSize * _layerHeight)  / _filamentArea;

        return _e;
    }

    private PathD? look_at_next_interstection(PathD prev, PathD lookup, PointD prevPoint, PathsD allPaths)
    {
        PointD lookupPoint = prevPoint;
        if (lookup == prev)
        {
            lookupPoint = prev[1];
        }
        else
        {
            foreach (var point in lookup)
            {
                if (point != prevPoint)
                {
                    lookupPoint = point;
                    break;
                }
            }
        }
        
        List<PathD> canidates = new List<PathD>();

        foreach (var path in allPaths)
        {
            if (path == prev || path == lookup)
            {
                continue;
            }
            
            foreach (var point in path)
            {
                if (point != prevPoint && Math.Abs(lookupPoint.x - point.x) < tolerance &&
                    Math.Abs(point.y - lookupPoint.y) < tolerance)
                {
                    canidates.Add(path);
                }
            }
        }

        if (canidates.Count == 0) return null;

        foreach (var canidate in canidates)
        {
            PointD pointToLookAt = canidate[0] != lookupPoint ? canidate[0] : canidate[1];

            if (Math.Abs(lookupPoint.x - pointToLookAt.x) < tolerance ||
                Math.Abs(pointToLookAt.y - lookupPoint.y) < tolerance)
            {
                return canidate;
            }
        }
        return canidates[0];
    }

    private PointD findCommon(PathD p1, PathD p2)
    {
        if (p1[0] == p2[0] || p1[0] == p2[1])
        {
            return p1[0];
        }

        return p1[1];
    }

    private PathsD createValidPath(PathD startPath, PathsD allPaths)
    {
        PathsD paths = new PathsD();
        paths.Add(startPath);
        
        PathD? foundPath = startPath;
        PathD prevPath = startPath;
        bool isFirst = true;
        PointD prevPoint = new PointD(0, 0);

        while (isFirst || foundPath != startPath)
        {
            PathD? temp = look_at_next_interstection(prevPath, foundPath, prevPoint, allPaths);
            if (temp == null)
            {
                break;
            }
            

            prevPath = foundPath;
            foundPath = temp;
            PathD createdPath = new PathD();
            createdPath.Add(prevPoint);
            createdPath.Add(findCommon(prevPath, temp));
            Console.WriteLine(createdPath[0].ToString() + createdPath[1].ToString());
            prevPoint = findCommon(prevPath, temp);
            if (foundPath != startPath)
            {
                paths.Add(foundPath);
            }

            isFirst = false;
        }

        foreach (var path in paths)
        {
            allPaths.Remove(path);
        }
        
        Console.WriteLine(paths.Count);
        return paths;

    }

    private List<PathsD> getValidPaths(PathsD paths)
    {
        List<PathsD> validPaths = new List<PathsD>();

        while (paths.Count > 0)
        {
            var nextSearch = paths[0];
            PathsD temp = createValidPath(nextSearch, paths);

            if (temp.Count >= 3)
            {
                Console.WriteLine(temp.Count);
                validPaths.Add(temp);
            }
        }
        
        return validPaths;
    }
    private void writeCustomGcode(FileStream fs, PathsD paths)
    {
        _e = 0.0;

        List<PathsD> validPaths = getValidPaths(paths);
        
        double sideLength = 50.0; // Side length of the square
        double feedRate = 500;   // Feed rate for movement
        
        string test = "";

        foreach (var validPath in validPaths)
        {
            PointD prev = new PointD(0, 0);
            bool isStart = true;
            PointD startPoint = new PointD(0, 0);
            foreach (var path in validPath)
            {
                foreach (var point in path)
                {
                    if (Math.Abs(prev.x - point.x) < tolerance && Math.Abs(point.y - prev.y) < tolerance) continue;
                    if (isStart)
                    {
                        test += $"G0 F2700 X{point.x + 110} Y{point.y + 110}" + _newline;
                        startPoint = point;
                        isStart = false;
                        prev = point;
                    }
                    else
                    {
                        test += $"G1 F{feedRate} X{point.x + 110} Y{point.y + 110} E{callculate_E(prev, point)}" +
                                _newline;
                        prev = point;
                    }

                }
            }
            test += $"G1 F{feedRate} X{startPoint.x + 110} Y{startPoint.y + 110} E{callculate_E(prev, startPoint)}" +
                    _newline;
        }


        // Convert string to bytes and write to the file
        byte[] commandBytes = Encoding.UTF8.GetBytes(test);
        fs.Write(commandBytes, 0, commandBytes.Length);
    }

    private void writeEndLines(FileStream fs)
    {
        string endlines ="G1 F2700 E277.51389" + _newline +
                            "M140 S0" + _newline +
                            "M107" + _newline +
                            "G91 ;Relative positioning" + _newline +
                            "G1 E-2 F2700 ;Retract a bit" + _newline + 
                            "G1 E-2 Z0.2 F2400 ;Retract and raise Z" + _newline +
                            "G1 X5 Y5 F3000 ;Wipe out" + _newline +
                            "G1 Z10 ;Raise Z more" + _newline + 
                            "G90 ;Absolute positioning" + _newline +
                            "G1 X0 Y235 ;Present print" + _newline +
                            "M106 S0 ;Turn-off fan" + _newline +
                            "M104 S0 ;Turn-off hotend" + _newline +
                            "M140 S0 ;Turn-off bed" + _newline +
                            "M84 X Y E ;Disable all steppers but Z" + _newline +
                            "M82 ;absolute extrusion mode" + _newline +
                            "M104 S0;" + _newline;
        
        byte[] commandBytes = Encoding.UTF8.GetBytes(endlines);
        fs.Write(commandBytes, 0, commandBytes.Length);
    }
}